#include "ros/ros.h"

#include <pcl/ModelCoefficients.h>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>

#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>

#include <sensor_msgs/PointCloud.h>
#include <sensor_msgs/Image.h>
#include <visualization_msgs/Marker.h>

#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/extract_indices.h>

#include <vector>

#include <kinect_utils/resamplePointCloud.h>

// these messages are defined in ./msg
// The headers are auto-generated by rosmake
#include "kinect_utils/kinectPose.h"
#include "kinect_utils/flightCommand.h"

#include "kinect_utils/helper.h"

#include <opencv/cv.h>
#include <opencv/highgui.h>
#include "cv_bridge/CvBridge.h"

#include <boost/interprocess/sync/interprocess_mutex.hpp>


using std::cout;
using std::endl;
using std::vector;

//! Little helper structure for the orientation angles.
struct Euler {
  double roll, pitch, yaw;
};


class CorridorExtraction 
{
 public:

  //! Possible wall types.
  enum WallType {ceiling, floor, left, right, front, unknown};

  //! Default constructor.
  CorridorExtraction();

  //! Default destructor.
  ~CorridorExtraction() {};

  //! Callback function for the ROS subscriber, is called everytime a /camera/point2 message is published somewhere.
  void pointCloudCallback(const sensor_msgs::PointCloud2ConstPtr& cloudMsg);
  
  //! Callback function the range image
  void rangeImageCallback(const sensor_msgs::ImageConstPtr& image_msg);

  //! finds a flight path through the corridor, respecting possible obstacles
  void findFlightPath();
 private:

  //! Finds parametric models of planes from the point cloud.
  /**
   * Uses a sample-consensus based method (RANSAC and the like) to find planes in the
   * 3D point cloud. 
   * This function fills the variables plane_cloud and plane_coefficients.
   * @parameter cloud The point cloud to be processed. Beware: It is altered eventually contains all points that could not be matched to a plane.
   */
  int extractPlanes( pcl::PointCloud <pcl::PointXYZ> &cloud);

  //! Determines the orientation angles for all the planes that are stored in plane_coefficients.
  /**
   * Results are written into plane_orientation.
   */
  void extractPlaneOrientations();

  //! Calculates the distance of the plane from the origin.
  /**
   * The plane is given in parameter form ax+by+cy+d=0.
   * Distance is returned in meters along the normal of the plane.
   */
  double extractPlaneDistance(double a, double b, double c, double d);

  //! Calculates the distance of the plane from the origin.
  /**
   * Convenience function, where the plane is given in pcl coefficnents.
   */
  double extractPlaneDistance(const pcl::ModelCoefficients &coeff);
  
  //! Estimates the orientation of the camera and its distance from the walls.
  /**
   * Needs some explanation:
   * From all the planes that are saved in plane_coefficients and so on,
   * the function determines the _largest_ left plane, the largest right plane
   * etc. for all wall types. 
   * These largest planes are used to determine the 
   * camera orientation: The yaw is estimated from the left and right plane 
   * by calculating the average of their yaw angles. Pitch is estimated as the
   * average pitch angle of the floor and ceiling. 
   * The roll is estimated as the avg. roll of all planes.
   *
   * To improve, use a weighted average, taking into account the number of points 
   * supporting each of the  involved planes. Maybe using the median distance 
   * to _all_ left walls etc. (not just the largest) could improve the quality.
   * 
   * Could fail e.g. if the largest plane happens to be _not_ the corridor wall, 
   * but an obstsacle. 
   * Also, don't misinterpret the results: The distance is meant to be the distance 
   * to the corridor wall, not to any obstacle. This is why, in the hope that potential
   * obstacles are small compared to the walls, only the largest planes
   * are considered here. 
   * 
   */
  void estimateCameraOrientationAndDistances();

  //! Determines the type of the planes in plane_coefficients.
  /**
   * This function looks at the largest component in the normal vector (a b c)' and its sign.
   * Results are written into plane_type.
   */
  void extractPlaneTypes();

  //! Publish the results.
  /**
   * Published variables are distances and cameraOrientation.
   */
  void publish();
 
  //! Publish visualization_msgs::Marker wall_marker for visualization of the extracted planes
  void publish_plane_marker();
  
  //! Publish visualization_msgs::Marker flightCommand_marker for visualization of the extracted planes
  void publish_command_marker();
  
  //! used to downsample the incoming point cloud
  pcl::VoxelGrid< pcl::PointXYZ > vg;	      

  //! the points of the extracted planes will be saved here
  vector<pcl::PointCloud<pcl::PointXYZ> > plane_cloud;

  //! this holds the 4 coefficients ax+by+cz+d=0 of the found planes
  vector<pcl::ModelCoefficients> plane_coefficients;
  
  //! the orientations of the planes
  vector<Euler> plane_orientation;

  //! distances of the extracted planes
  vector<double> plane_distance;

  //! types of the walls (can be any of left, right, ceiling, floor, front or unknown)
  vector<WallType> plane_type;  	


  //! A message class that publishes distances and orientations relative to the corridor walls
  /**
   * Distance is given in meters. And refers to the shortest distance
   * along the wall-normal.
   * If the distance could not be determined, 
   * e.g. because the wall was not seen, it is set to -1.
   * Pitch, yaw and roll angles in rad relative to the corridor walls.
   */
  kinect_utils::kinectPose kinectPose; 

  //! The ROS publisher class that publishes all those points that could not be matched to a plane
  ros::Publisher pub_unmatched;
  
  //! The ROS publisher class for visualization of planes
  ros::Publisher pub_wall_marker;
  
  //! The ROS publisher class for visualization of flight command
  ros::Publisher pub_command_marker;
  
  //! The ROS publisher class that publishes the combined orientation and distances message
  ros::Publisher pub_kinectPose;

  //! The ROS publisher that publishes flight commands that should enable the UAV to fly through the corridor.
  ros::Publisher pub_command;

  //! Variable to save the unmatched points that are published by the publisher above.
  sensor_msgs::PointCloud2 unmatchedPointsMsg;
 
  //! Maximum number of planes
  int max_n_planes;

  //! most recent range image
  cv::Mat rangeImage;

  //! an instance of a CvBridge
  sensor_msgs::CvBridge cvBridge;

  kinect_utils::flightCommand flightCommand;

  //a mutex to lock access to the rangeImage
  boost::interprocess::interprocess_mutex mutex;
  
  int weight_left, weight_right, weight_front, weight_ceiling, weight_floor;

};
  
